# В этом доке находятся решения всех уникальных задач из документа

# Вариант 1
"""
Дано натуральное число N. Выведите все его цифры по одной, в обратном порядке, разделяя
их пробелами или новыми строками. При решении этой задачи нельзя использовать строки,
списки, массивы (ну и циклы, разумеется). Разрешена только рекурсия и целочисленная
арифметика.
"""
def task1(n: int):
    if n // 10 == 0: # базовый кейс рекурсии
        print(n)
        return n
    print(n % 10, end=" ") # взятие последней цифры числа
    task1(n // 10) # вызов для числа без последней цифры

"""
Для заданного четырехзначного числа найти разницу между наибольшей и наименьшей
цифрой. Ограничений по использованию циклов и массивов нет.
"""
# решил для произвольного
def task2(n: int): 
    delimiter = 1 # каждый раз будем увеличивать делитель, отбрасывая последние цифры числа
    cur_max = n % 10
    cur_min = n % 10

    while n // delimiter > 0: # пока не пройдем все разряды
        if n // delimiter % 10 > cur_max:
            cur_max = n // delimiter % 10
        if n // delimiter % 10 < cur_min:
            cur_min = n // delimiter % 10
        
        delimiter *= 10
    print(f"Max is {cur_max}")
    print(f"Min is {cur_min}")
    print(f"Difference is {cur_max - cur_min}")



"""
Напишите программу, которая сортирует массив, а затем находит максимальное из чисел,
встречающихся в массиве несколько раз (т.е. более одного). Не использовать встроенные
функции
"""

def task3_sort(arr: list):
    if len(arr) < 2:
        return arr
    else:
        pivot = arr[0]
        small = [i for i in arr[1:] if i <= pivot]
        big = [i for i in arr[1:] if i > pivot]
        return task3_sort(small) + [pivot] + task3_sort(big)



def task3_main(arr: list):
    sorted_arr = task3_sort(arr)
    cur_max = sorted_arr[0]
    hash_arr = {}

    for element in sorted_arr:
        if element not in hash_arr:
            hash_arr[element] = 0
        hash_arr[element] += 1

    for item in hash_arr:
        if  hash_arr[item] > 1 and item > cur_max:
            cur_max = item
            

# Вариант 2

"""
Дано натуральное число N. Выведите все его цифры по одной, в обычном порядке, разделяя
их пробелами или новыми строками. При решении этой задачи нельзя использовать строки,
списки, массивы (ну и циклы, разумеется). Разрешена только рекурсия и целочисленная
арифметика
"""

def task4(n: int):
    if n // 10 == 0: # базовый кейс рекурсии
        print(n, end=" ")
        return n
    task4(n // 10)
    print(n % 10, end=" ")


"""
Распечатать все шестизначные числа, в записи которых нет повторяющихся цифр, и вывести
их количество. Ограничений по использованию циклов и массивов нет.
"""

# я очень быстро устал писать комментарии()

def task5_unique_digits(n): # попробовал составить хэш для каждого числа
    delimiter = 1
    number_hash = {}
    while n // delimiter > 0:
        if n // delimiter % 10 not in number_hash:
            number_hash[n // delimiter % 10] = 0
        number_hash[n // delimiter % 10] += 1
        if number_hash[n // delimiter % 10] > 1:
            return False
        delimiter *= 10
    return True

def task5(n: int): # Принимает количество разрядов 
    counter = 0
    for i in range(10*(n-1), 10*n):
        if task5_unique_digits(i):
            counter += 1
            print(i)
    print(counter)


"""
Дан массив. Назовем серией группу подряд идущих одинаковых элементов, а длиной серии
— количество этих элементов. Отсортировать массив и сформировать два новых массива, в
один из них записывать длины всех серий, а во второй — значения элементов, образующих
эти серии. Например, если исходный массив [3, 5, 1, 3, 5, 3] то элементы, создающие серии,
это [3, 5], а длины серий - [3,2].
"""
def task6(arr: list):
    sorted_arr = task3_sort(arr) # воспользовался быстрой сортировкой из 3
    # если я правильно понимаю задание, то оно сводится к подсчету повторяющихся элементов
    # в таком случае сюда просто ОТЛИЧНО ляжет хэш (я буду это использовать пока не умру)
    hash_arr = {}
    for i in sorted_arr:
        if i not in hash_arr:
            hash_arr[i] = 0
        hash_arr[i] += 1
    
    print([i for i in list(hash_arr.keys()) if hash_arr[i] > 1])
    print([hash_arr[i] for i in list(hash_arr.keys()) if hash_arr[i] > 1])

# Вариант 3
"""
Дано натуральное число N. Вычислите сумму его цифр. При решении этой задачи нельзя
использовать строки, списки, массивы (ну и циклы, разумеется).
"""
def task7(n: int):
    if n // 10 == 0:
        return n
    else:
        return n % 10 + task7(n // 10)
    


"""
Для заданного шестизначного числа найти разницу между наибольшей и наименьшей
цифрой. Ограничений по использованию циклов и массивов нет.

Решил для произвольного
task 2

Напишите программу, которая сортирует массив, а затем находит максимальное из чисел,
встречающихся в массиве несколько раз (т.е. более одного). Не использовать встроенные
функции.
task3
"""

# Вариант 4
"""
Дано натуральное число N. Выведите все его цифры по одной, в обратном порядке, разделяя
их пробелами или новыми строками. При решении этой задачи нельзя использовать строки,
списки, массивы (ну и циклы, разумеется). Разрешена только рекурсия и целочисленная
арифметика.
task1

Распечатать все четырехзначные числа, в записи которых нет повторяющихся цифр, и
вывести их количество. Ограничений по использованию циклов и массивов нет.

Решил с приемом количества разрядов 
task5


Дан массив. Назовем серией группу подряд идущих одинаковых элементов, а длиной серии
— количество этих элементов. Отсортировать массив и сформировать два новых массива, в
один из них записывать длины всех серий, а во второй — значения элементов, образующих
эти серии. Например, если исходный массив [3, 5, 1, 3, 5, 3] то элементы, создающие серии,
это [3, 5], а длины серий - [3,2].

task6

"""

def main():
    task2(123456)
if __name__ == "__main__":
    main()
